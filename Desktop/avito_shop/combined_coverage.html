
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>buy_token: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">avito_shop/e2e/buy_token/e2e.go (0.0%)</option>
				
				<option value="file1">avito_shop/internal/authentication/hash.go (100.0%)</option>
				
				<option value="file2">avito_shop/internal/authentication/jwt.go (100.0%)</option>
				
				<option value="file3">avito_shop/internal/cmd/main.go (0.0%)</option>
				
				<option value="file4">avito_shop/internal/core/core.go (93.2%)</option>
				
				<option value="file5">avito_shop/internal/handlers/handlers.go (0.0%)</option>
				
				<option value="file6">avito_shop/internal/handlers/middleware.go (0.0%)</option>
				
				<option value="file7">avito_shop/internal/routes/routes.go (0.0%)</option>
				
				<option value="file8">avito_shop/internal/storage/db.go (0.0%)</option>
				
				<option value="file9">avito_shop/internal/storage/db_mock.go (58.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package buytoken

// Basic imports
import (
        "testing"

        "github.com/stretchr/testify/assert"
        "github.com/stretchr/testify/suite"
)

// Define the suite, and absorb the built-in basic suite
// functionality from testify - including a T() method which
// returns the current testing context
type ExampleTestSuite struct {
        suite.Suite
        VariableThatShouldStartAtFive int
}

// Make sure that VariableThatShouldStartAtFive is set to five
// before each test
func (suite *ExampleTestSuite) SetupTest() <span class="cov0" title="0">{
        suite.VariableThatShouldStartAtFive = 5
}</span>

// All methods that begin with "Test" are run as tests within a
// suite.
func (suite *ExampleTestSuite) TestExample() <span class="cov0" title="0">{
        assert.Equal(suite.T(), 5, suite.VariableThatShouldStartAtFive)
}</span>

// In order for 'go test' to run this suite, we need to create
// a normal test function and pass our suite to suite.Run
func TestExampleTestSuite(t *testing.T) <span class="cov0" title="0">{
        suite.Run(t, new(ExampleTestSuite))
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package authentication

import (
        "golang.org/x/crypto/bcrypt"
)

// HashPassword хэширует пароль
func HashPassword(password string) (string, error) <span class="cov8" title="1">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(bytes), nil</span>
}

// CheckPasswordHash проверяет соответствие пароля и его хэша
func CheckPasswordHash(password, hash string) bool <span class="cov8" title="1">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package authentication

import (
        "avito_shop/internal/models"
        "errors"
        "time"
)

type TokenClaims struct {
        Employee struct {
                Username string `json:"username"`
        } `json:"user"`
        IAT int64 `json:"iat"`
        EXP int64 `json:"exp"`
}

type RegisterResponse struct {
        AccessToken string `json:"token"`
}

func GenerateTokenClaims(employee *models.Employee, now time.Time) *TokenClaims <span class="cov8" title="1">{
        username := employee.Username

        newTokenClaims := &amp;TokenClaims{
                Employee: struct {
                        Username string `json:"username"`
                }{
                        Username: username,
                },
                IAT: now.Unix(),
                EXP: now.Add(time.Hour * 12).Unix(),
        }

        return newTokenClaims
}</span>

func (c *TokenClaims) Valid() error <span class="cov8" title="1">{
        currentTime := time.Now().Unix()

        if c.EXP &lt; currentTime </span><span class="cov8" title="1">{
                return errors.New("токен истек")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

var SecretKey = []byte("mykey")
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "avito_shop/internal/core"
        "avito_shop/internal/handlers"
        "avito_shop/internal/routes"
        "avito_shop/internal/storage"
        "context"
        "fmt"
        "log"
        "net/http"

        gorillaHandlers "github.com/gorilla/handlers"
)

func main() <span class="cov0" title="0">{
        cfg := storage.PostgresConnConfig{
                DBHost:   "db",
                DBPort:   5432,
                DBName:   "shop",
                Username: "postgres",
                Password: "password",
                Options:  nil,
        }

        // Создание соединения с базой данных
        conn, err := storage.New(context.Background(), cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Не удалось подключиться к базе данных: %v", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close(context.Background())

        avitoDB := storage.NewAvitoDB(conn)
        authService := core.New(avitoDB)
        userHandler := handlers.NewUserHandler(authService)

        mux := routes.InitRoutes(userHandler)

        corsHandler := gorillaHandlers.CORS(
                gorillaHandlers.AllowedOrigins([]string{"*"}), // Разрешить все домены, но лучше указать конкретные
                gorillaHandlers.AllowedMethods([]string{"GET", "POST", "PUT", "DELETE", "OPTIONS"}),
                gorillaHandlers.AllowedHeaders([]string{"Content-Type", "Authorization"}),
        )

        fmt.Println("Запуск сервера на порту 8080 http://localhost:8080/")
        log.Fatal(http.ListenAndServe(":8080", corsHandler(mux)))</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">//go:generate mockery --filename  core_mock.go --name Interface --inpackage --with-expecter
package core

import (
        "avito_shop/internal/authentication"
        "avito_shop/internal/models"
        "avito_shop/internal/storage"
        "context"
        "fmt"
        "time"

        "github.com/golang-jwt/jwt"
)

type Interface interface {
        Auth(ctx context.Context, employee *models.Employee, now time.Time) (string, error)
        BuyItem(ctx context.Context, item string, username string) error
        SendCoin(ctx context.Context, send *models.SendCoin, username string) error
        Info(ctx context.Context, username string) (models.InfoResponse, error)
}

type service struct {
        storage storage.Interface
}

func New(storage storage.Interface) Interface <span class="cov0" title="0">{
        return &amp;service{
                storage: storage,
        }
}</span>

func (s *service) Auth(ctx context.Context, employee *models.Employee, now time.Time) (string, error) <span class="cov8" title="1">{
        if employee.Username == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("неправильные входные данные")
        }</span>

        <span class="cov8" title="1">ok, err := s.storage.CheckEmployee(employee.Username)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                //сначала хэшируем пароль
                hashedPassword, err := authentication.HashPassword(employee.Password)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("не удалось хэшировать пароль: %w", err)
                }</span>
                <span class="cov8" title="1">employee.Password = hashedPassword

                // потом выдаем токен
                jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, authentication.GenerateTokenClaims(employee, now))
                tokenString, err := jwtToken.SignedString(authentication.SecretKey)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("не удалось создать токен")
                }</span>

                <span class="cov8" title="1">employee.Token = tokenString

                err = s.storage.Register(employee)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>

                <span class="cov8" title="1">return tokenString, nil</span>
        }

        <span class="cov8" title="1">foundEmployee, err := s.storage.Login(employee)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if !authentication.CheckPasswordHash(employee.Password, foundEmployee.Password) </span><span class="cov8" title="1">{
                return "", fmt.Errorf("неверный пароль")
        }</span>

        <span class="cov8" title="1">jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, authentication.GenerateTokenClaims(&amp;foundEmployee, now))

        tokenString, err := jwtToken.SignedString(authentication.SecretKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("не удалось создать токен")
        }</span>

        <span class="cov8" title="1">err = s.storage.UpdateToken(foundEmployee.ID, tokenString)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("не удалось обновить токен")
        }</span>

        <span class="cov8" title="1">return tokenString, nil</span>
}

func (s *service) BuyItem(ctx context.Context, item string, username string) error <span class="cov8" title="1">{
        err := s.storage.BuyItem(item, username)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *service) SendCoin(ctx context.Context, send *models.SendCoin, username string) error <span class="cov8" title="1">{
        send.FromUser = username

        if send.ToUser == send.FromUser || send.Amount &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("самому себе отправить монеты нельзя, нельзя отправить отрицательное значение")
        }</span>

        <span class="cov8" title="1">err := s.storage.SendCoin(send)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *service) Info(ctx context.Context, username string) (models.InfoResponse, error) <span class="cov8" title="1">{
        coins, err := s.storage.GetCoins(username)
        if err != nil </span><span class="cov8" title="1">{
                return models.InfoResponse{}, err
        }</span>

        <span class="cov8" title="1">items, err := s.storage.GetInventory(username)
        if err != nil </span><span class="cov8" title="1">{
                return models.InfoResponse{}, err
        }</span>

        <span class="cov8" title="1">sent, received, err := s.storage.GetTransaction(username)
        if err != nil </span><span class="cov8" title="1">{
                return models.InfoResponse{}, err
        }</span>

        <span class="cov8" title="1">var response models.InfoResponse

        response.Coins = coins
        response.Inventory = items

        coinHistory := models.CoinHistory{
                Received: received,
                Sent:     sent,
        }
        response.CoinHistory = coinHistory

        return response, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "avito_shop/internal/authentication"
        "avito_shop/internal/core"
        "avito_shop/internal/models"
        "encoding/json"
        "net/http"
        "time"

        "github.com/gorilla/mux"
)

type UserHandler struct {
        service core.Interface
}

func NewUserHandler(service core.Interface) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{service: service}
}</span>

func (h *UserHandler) Auth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var newEmployees models.Employee

        if err := json.NewDecoder(r.Body).Decode(&amp;newEmployees); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Невалидные данные", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">defer r.Body.Close()

        tokenString, err := h.service.Auth(r.Context(), &amp;newEmployees, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusConflict)
                return
        }</span>

        <span class="cov0" title="0">response := authentication.RegisterResponse{AccessToken: tokenString}
        json.NewEncoder(w).Encode(response)</span>
}

func (h *UserHandler) BuyItem(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        vars := mux.Vars(r)
        item := vars["item"]

        username, ok := GetUsername(r.Context())
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "не удалось извлечь имя пользователя из контекста", http.StatusUnauthorized)
                return
        }</span>

        <span class="cov0" title="0">err := h.service.BuyItem(r.Context(), item, username)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusConflict)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *UserHandler) SendCoin(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var newSend models.SendCoin

        if err := json.NewDecoder(r.Body).Decode(&amp;newSend); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Невалидные данные", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()

        username, ok := r.Context().Value(usernameKey).(string)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "не удалось извлечь имя пользователя из контекста", http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">err := h.service.SendCoin(r.Context(), &amp;newSend, username)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusConflict)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

func (h *UserHandler) Info(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        username, ok := r.Context().Value(usernameKey).(string)
        if !ok </span><span class="cov0" title="0">{
                http.Error(w, "не удалось извлечь имя пользователя из контекста", http.StatusUnauthorized)
                return
        }</span>
        <span class="cov0" title="0">response, err := h.service.Info(r.Context(), username)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusConflict)
                return
        }</span>
        // Форматируем JSON с отступами
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)
        jsonResponse, err := json.MarshalIndent(response, "", "  ") // Здесь задаем отступы
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Write(jsonResponse)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "avito_shop/internal/authentication"
        "context"
        "fmt"
        "net/http"
        "strings"

        "github.com/golang-jwt/jwt"
)

type contextUsername string

const usernameKey contextUsername = "username"

func (h *UserHandler) AuthMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                // Извлечение токена из заголовка Authorization
                authHeader := r.Header.Get("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        http.Error(w, "Токен не предоставлен", http.StatusUnauthorized)
                        return
                }</span>

                // Проверка формата токена
                <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                if tokenString == authHeader </span><span class="cov0" title="0">{ // Если токен не был найден
                        http.Error(w, "Неверный формат токена", http.StatusUnauthorized)
                        return
                }</span>

                // Далее идет проверка токена...
                <span class="cov0" title="0">claims := &amp;authentication.TokenClaims{}
                jwtToken, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("неверный метод подписи")
                        }</span>
                        <span class="cov0" title="0">return authentication.SecretKey, nil</span>
                })

                <span class="cov0" title="0">if err != nil || !jwtToken.Valid </span><span class="cov0" title="0">{
                        http.Error(w, "Неверный токен", http.StatusUnauthorized)
                        return
                }</span>

                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), usernameKey, claims.Employee.Username)
                r = r.WithContext(ctx)

                next.ServeHTTP(w, r)</span>
        })
}

func GetUsername(ctx context.Context) (string, bool) <span class="cov0" title="0">{
        return "nil", true
        //r.Context().Value(usernameKey).(string)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package routes

import (
        "avito_shop/internal/handlers"

        "github.com/gorilla/mux"
)

const (
        Item = "item"
)

func InitRoutes(userHandler *handlers.UserHandler) *mux.Router <span class="cov0" title="0">{
        api := mux.NewRouter()

        api.HandleFunc("/api/auth", userHandler.Auth).Methods("POST")

        // Создание подмаршрута для /api с middleware
        authHandler := api.PathPrefix("/api").Subrouter()
        authHandler.Use(userHandler.AuthMiddleware)

        authHandler.HandleFunc("/buy/{"+Item+"}", userHandler.BuyItem).Methods("GET")
        authHandler.HandleFunc("/sendCoin", userHandler.SendCoin).Methods("POST")
        authHandler.HandleFunc("/info", userHandler.Info).Methods("GET")
        return api
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">//go:generate mockery --filename db_mock.go --name Interface --inpackage --with-expecter
package storage

import (
        "avito_shop/internal/models"
        "context"
        "fmt"

        "github.com/jackc/pgx/v5"
)

type Interface interface {
        CheckEmployee(username string) (bool, error)
        Register(employee *models.Employee) error
        Login(employee *models.Employee) (models.Employee, error)
        UpdateToken(id int, token string) error
        BuyItem(item string, username string) error
        SendCoin(send *models.SendCoin) error
        GetCoins(username string) (int, error)
        GetInventory(username string) ([]models.Item, error)
        GetTransaction(username string) ([]models.SentTransaction, []models.ReceivedTransaction, error)
}

type PostgresConnConfig struct {
        DBHost   string
        DBPort   uint
        DBName   string
        Username string
        Password string
        Options  map[string]string
}

type AvitoDB struct {
        conn *pgx.Conn
}

func NewAvitoDB(conn *pgx.Conn) *AvitoDB <span class="cov0" title="0">{
        return &amp;AvitoDB{conn: conn}
}</span>

func New(ctx context.Context, cfg PostgresConnConfig) (*pgx.Conn, error) <span class="cov0" title="0">{
        connStr := fmt.Sprintf("postgres://%s:%s@%s:%d/%s",
                cfg.Username, cfg.Password, cfg.DBHost, cfg.DBPort, cfg.DBName,
        )

        var options string
        if len(cfg.Options) &gt; 0 </span><span class="cov0" title="0">{
                for key, value := range cfg.Options </span><span class="cov0" title="0">{
                        options += fmt.Sprintf("%s=%s&amp;", key, value)
                }</span>

                <span class="cov0" title="0">options = options[:len(options)-1]
                connStr += options</span>
        }

        <span class="cov0" title="0">conn, err := pgx.Connect(ctx, connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error connecting to postgres: %w", err)
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}

func (s *AvitoDB) CheckEmployee(username string) (bool, error) <span class="cov0" title="0">{
        var exists bool
        err := s.conn.QueryRow(context.Background(), "SELECT EXISTS(SELECT 1 FROM employees WHERE username = $1)", username).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("ошибка при проверке существования пользователя: %w", err)
        }</span>
        <span class="cov0" title="0">return exists, nil</span>
}

func (s *AvitoDB) Register(employee *models.Employee) error <span class="cov0" title="0">{
        err := s.conn.QueryRow(context.Background(), "INSERT INTO employees (username, password, token) VALUES ($1, $2, $3) RETURNING id", employee.Username, employee.Password, employee.Token).Scan(&amp;employee.ID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при регистрации пользователя: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *AvitoDB) Login(employee *models.Employee) (models.Employee, error) <span class="cov0" title="0">{
        var foundEmployee models.Employee
        err := s.conn.QueryRow(context.Background(), "SELECT id, username, password, coins FROM employees WHERE username = $1", employee.Username).Scan(&amp;foundEmployee.ID, &amp;foundEmployee.Username, &amp;foundEmployee.Password, &amp;foundEmployee.Coins)
        if err != nil </span><span class="cov0" title="0">{
                return models.Employee{}, fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>

        <span class="cov0" title="0">return foundEmployee, nil</span>
}

func (s *AvitoDB) UpdateToken(id int, token string) error <span class="cov0" title="0">{
        _, err := s.conn.Exec(context.Background(), "UPDATE employees SET token = $1 WHERE id = $2", token, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при обновлении токена: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *AvitoDB) BuyItem(item string, username string) error <span class="cov0" title="0">{
        var priceItem int
        var employeeID int
        var merchandiseID int

        // Получаем цену товара
        err := s.conn.QueryRow(context.Background(), "SELECT price FROM merchandise WHERE name = $1", item).Scan(&amp;priceItem)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("товара не существует: %w", err)
        }</span>

        // Получаем ID пользователя
        <span class="cov0" title="0">err = s.conn.QueryRow(context.Background(), "SELECT id FROM employees WHERE username = $1", username).Scan(&amp;employeeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("пользователь не найден: %w", err)
        }</span>

        // Получаем ID товара
        <span class="cov0" title="0">err = s.conn.QueryRow(context.Background(), "SELECT id FROM merchandise WHERE name = $1", item).Scan(&amp;merchandiseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("товар не найден: %w", err)
        }</span>

        // Обновляем количество монет у пользователя
        <span class="cov0" title="0">result, err := s.conn.Exec(context.Background(), `
                UPDATE employees 
                SET coins = coins - $1 
                WHERE id = $2 AND coins &gt;= $1`, priceItem, employeeID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при обновлении монет: %w", err)
        }</span>

        <span class="cov0" title="0">rowsAffected := result.RowsAffected()

        if rowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("недостаточно монет для покупки товара")
        }</span>

        // Добавляем товар в инвентарь
        <span class="cov0" title="0">_, err = s.conn.Exec(context.Background(), `
                INSERT INTO inventory (employee_id, merchandise_id, quantity)
                VALUES ($1, $2, 1)
                ON CONFLICT (employee_id, merchandise_id) 
                DO UPDATE SET quantity = inventory.quantity + 1`, employeeID, merchandiseID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при добавлении товара в инвентарь: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *AvitoDB) SendCoin(send *models.SendCoin) error <span class="cov0" title="0">{
        var senderCoins int
        var senderID int
        var receiverID int

        // Получаем баланс отправителя
        err := s.conn.QueryRow(context.Background(), "SELECT coins, id FROM employees WHERE username = $1", send.FromUser).Scan(&amp;senderCoins, &amp;senderID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("пользователь-отправитель не найден: %w", err)
        }</span>

        // Проверяем, достаточно ли монет у отправителя
        <span class="cov0" title="0">if senderCoins &lt; send.Amount </span><span class="cov0" title="0">{
                return fmt.Errorf("недостаточно монет у отправителя %s", send.FromUser)
        }</span>

        // Получаем ID получателя
        <span class="cov0" title="0">err = s.conn.QueryRow(context.Background(), "SELECT id FROM employees WHERE username = $1", send.ToUser).Scan(&amp;receiverID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("пользователь-получатель не найден: %w", err)
        }</span>

        // Обновляем количество монет у отправителя
        <span class="cov0" title="0">_, err = s.conn.Exec(context.Background(), `
        UPDATE employees 
        SET coins = coins - $1 
        WHERE id = $2`, send.Amount, senderID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при списании монет у отправителя: %w", err)
        }</span>

        // Начисляем монеты получателю
        <span class="cov0" title="0">_, err = s.conn.Exec(context.Background(), `
        UPDATE employees 
        SET coins = coins + $1 
        WHERE id = $2`, send.Amount, receiverID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при начислении монет получателю: %w", err)
        }</span>

        // Записываем историю транзакций
        <span class="cov0" title="0">_, err = s.conn.Exec(context.Background(), `
        INSERT INTO transactions (employee_id, transaction_type, amount, from_user, to_user) 
        VALUES ($1, 'sent', $2, $3, NULL)`, senderID, send.Amount, send.FromUser)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при записи транзакции отправителя: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = s.conn.Exec(context.Background(), `
        INSERT INTO transactions (employee_id, transaction_type, amount, from_user, to_user) 
        VALUES ($1, 'received', $2, NULL, $3)`, receiverID, send.Amount, send.ToUser)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ошибка при записи транзакции получателя: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *AvitoDB) GetCoins(username string) (int, error) <span class="cov0" title="0">{
        var coins int

        err := s.conn.QueryRow(context.Background(), "SELECT coins FROM employees WHERE username = $1", username).Scan(&amp;coins)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("не удалось получить монеты: %w", err)
        }</span>

        <span class="cov0" title="0">return coins, nil</span>
}

func (s *AvitoDB) GetInventory(username string) ([]models.Item, error) <span class="cov0" title="0">{
        var items []models.Item

        // Выполняем SQL-запрос для получения данных из инвентаря
        rows, err := s.conn.Query(context.Background(), `
        SELECT m.name AS type, i.quantity 
        FROM inventory i
        JOIN employees e ON i.employee_id = e.id
        JOIN merchandise m ON i.merchandise_id = m.id
        WHERE e.username = $1`, username)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при выполнении запроса: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        // Проходим по результатам запроса
        for rows.Next() </span><span class="cov0" title="0">{
                var item models.Item
                if err := rows.Scan(&amp;item.Type, &amp;item.Quantity); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("ошибка при считывании строки: %w", err)
                }</span>
                <span class="cov0" title="0">items = append(items, item)</span>
        }

        // Проверяем на наличие ошибок после итерации
        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ошибка при итерации по строкам: %w", err)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

func (s *AvitoDB) GetTransaction(username string) ([]models.SentTransaction, []models.ReceivedTransaction, error) <span class="cov0" title="0">{
        var employeesID int
        // Получили айди
        err := s.conn.QueryRow(context.Background(), "SELECT id FROM employees WHERE username = $1", username).Scan(&amp;employeesID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("пользователь-получатель не найден: %w", err)
        }</span>

        // Запрос для получения всех транзакций типа 'sent'
        <span class="cov0" title="0">rows, err := s.conn.Query(context.Background(), "SELECT amount, from_user FROM transactions WHERE transaction_type = 'sent' AND employee_id = $1", employeesID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("ошибка при получении транзакций: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var sentTransactions []models.SentTransaction

        // Обработка результатов запроса
        for rows.Next() </span><span class="cov0" title="0">{
                var t models.SentTransaction

                err := rows.Scan(&amp;t.Amount, &amp;t.FromUser)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("ошибка при сканировании строки: %w", err)
                }</span>

                <span class="cov0" title="0">sentTransactions = append(sentTransactions, t)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("ошибка при итерации по строкам: %w", err)
        }</span>

        // Запрос для получения всех транзакций типа 'received'
        <span class="cov0" title="0">receivedRows, err := s.conn.Query(context.Background(), "SELECT amount, to_user FROM transactions WHERE transaction_type = 'received' AND employee_id = $1", employeesID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("ошибка при получении полученных транзакций: %w", err)
        }</span>
        <span class="cov0" title="0">defer receivedRows.Close()

        var receivedTransactions []models.ReceivedTransaction

        // Обработка результатов запроса для 'received'
        for receivedRows.Next() </span><span class="cov0" title="0">{
                var t models.ReceivedTransaction

                err := receivedRows.Scan(&amp;t.Amount, &amp;t.ToUser)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("ошибка при сканировании строки полученных транзакций: %w", err)
                }</span>

                <span class="cov0" title="0">receivedTransactions = append(receivedTransactions, t)</span>
        }

        <span class="cov0" title="0">if err := receivedRows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("ошибка при итерации по строкам полученных транзакций: %w", err)
        }</span>

        <span class="cov0" title="0">return sentTransactions, receivedTransactions, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Code generated by mockery v2.52.2. DO NOT EDIT.

package storage

import (
        models "avito_shop/internal/models"

        mock "github.com/stretchr/testify/mock"
)

// MockInterface is an autogenerated mock type for the Interface type
type MockInterface struct {
        mock.Mock
}

type MockInterface_Expecter struct {
        mock *mock.Mock
}

func (_m *MockInterface) EXPECT() *MockInterface_Expecter <span class="cov8" title="1">{
        return &amp;MockInterface_Expecter{mock: &amp;_m.Mock}
}</span>

// BuyItem provides a mock function with given fields: item, username
func (_m *MockInterface) BuyItem(item string, username string) error <span class="cov8" title="1">{
        ret := _m.Called(item, username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for BuyItem")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(item, username)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockInterface_BuyItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuyItem'
type MockInterface_BuyItem_Call struct {
        *mock.Call
}

// BuyItem is a helper method to define mock.On call
//   - item string
//   - username string
func (_e *MockInterface_Expecter) BuyItem(item interface{}, username interface{}) *MockInterface_BuyItem_Call <span class="cov0" title="0">{
        return &amp;MockInterface_BuyItem_Call{Call: _e.mock.On("BuyItem", item, username)}
}</span>

func (_c *MockInterface_BuyItem_Call) Run(run func(item string, username string)) *MockInterface_BuyItem_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_BuyItem_Call) Return(_a0 error) *MockInterface_BuyItem_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockInterface_BuyItem_Call) RunAndReturn(run func(string, string) error) *MockInterface_BuyItem_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// CheckEmployee provides a mock function with given fields: username
func (_m *MockInterface) CheckEmployee(username string) (bool, error) <span class="cov8" title="1">{
        ret := _m.Called(username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CheckEmployee")</span>
        }

        <span class="cov8" title="1">var r0 bool
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (bool, error)); ok </span><span class="cov0" title="0">{
                return rf(username)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockInterface_CheckEmployee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckEmployee'
type MockInterface_CheckEmployee_Call struct {
        *mock.Call
}

// CheckEmployee is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) CheckEmployee(username interface{}) *MockInterface_CheckEmployee_Call <span class="cov8" title="1">{
        return &amp;MockInterface_CheckEmployee_Call{Call: _e.mock.On("CheckEmployee", username)}
}</span>

func (_c *MockInterface_CheckEmployee_Call) Run(run func(username string)) *MockInterface_CheckEmployee_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_CheckEmployee_Call) Return(_a0 bool, _a1 error) *MockInterface_CheckEmployee_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockInterface_CheckEmployee_Call) RunAndReturn(run func(string) (bool, error)) *MockInterface_CheckEmployee_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetCoins provides a mock function with given fields: username
func (_m *MockInterface) GetCoins(username string) (int, error) <span class="cov8" title="1">{
        ret := _m.Called(username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCoins")</span>
        }

        <span class="cov8" title="1">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(username)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockInterface_GetCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCoins'
type MockInterface_GetCoins_Call struct {
        *mock.Call
}

// GetCoins is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) GetCoins(username interface{}) *MockInterface_GetCoins_Call <span class="cov8" title="1">{
        return &amp;MockInterface_GetCoins_Call{Call: _e.mock.On("GetCoins", username)}
}</span>

func (_c *MockInterface_GetCoins_Call) Run(run func(username string)) *MockInterface_GetCoins_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_GetCoins_Call) Return(_a0 int, _a1 error) *MockInterface_GetCoins_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockInterface_GetCoins_Call) RunAndReturn(run func(string) (int, error)) *MockInterface_GetCoins_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetInventory provides a mock function with given fields: username
func (_m *MockInterface) GetInventory(username string) ([]models.Item, error) <span class="cov8" title="1">{
        ret := _m.Called(username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetInventory")</span>
        }

        <span class="cov8" title="1">var r0 []models.Item
        var r1 error
        if rf, ok := ret.Get(0).(func(string) ([]models.Item, error)); ok </span><span class="cov0" title="0">{
                return rf(username)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) []models.Item); ok </span><span class="cov0" title="0">{
                r0 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]models.Item)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockInterface_GetInventory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInventory'
type MockInterface_GetInventory_Call struct {
        *mock.Call
}

// GetInventory is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) GetInventory(username interface{}) *MockInterface_GetInventory_Call <span class="cov8" title="1">{
        return &amp;MockInterface_GetInventory_Call{Call: _e.mock.On("GetInventory", username)}
}</span>

func (_c *MockInterface_GetInventory_Call) Run(run func(username string)) *MockInterface_GetInventory_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_GetInventory_Call) Return(_a0 []models.Item, _a1 error) *MockInterface_GetInventory_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockInterface_GetInventory_Call) RunAndReturn(run func(string) ([]models.Item, error)) *MockInterface_GetInventory_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// GetTransaction provides a mock function with given fields: username
func (_m *MockInterface) GetTransaction(username string) ([]models.SentTransaction, []models.ReceivedTransaction, error) <span class="cov8" title="1">{
        ret := _m.Called(username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetTransaction")</span>
        }

        <span class="cov8" title="1">var r0 []models.SentTransaction
        var r1 []models.ReceivedTransaction
        var r2 error
        if rf, ok := ret.Get(0).(func(string) ([]models.SentTransaction, []models.ReceivedTransaction, error)); ok </span><span class="cov0" title="0">{
                return rf(username)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) []models.SentTransaction); ok </span><span class="cov0" title="0">{
                r0 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).([]models.SentTransaction)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) []models.ReceivedTransaction); ok </span><span class="cov0" title="0">{
                r1 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(1) != nil </span><span class="cov8" title="1">{
                        r1 = ret.Get(1).([]models.ReceivedTransaction)
                }</span>
        }

        <span class="cov8" title="1">if rf, ok := ret.Get(2).(func(string) error); ok </span><span class="cov0" title="0">{
                r2 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r2 = ret.Error(2)
        }</span>

        <span class="cov8" title="1">return r0, r1, r2</span>
}

// MockInterface_GetTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransaction'
type MockInterface_GetTransaction_Call struct {
        *mock.Call
}

// GetTransaction is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) GetTransaction(username interface{}) *MockInterface_GetTransaction_Call <span class="cov8" title="1">{
        return &amp;MockInterface_GetTransaction_Call{Call: _e.mock.On("GetTransaction", username)}
}</span>

func (_c *MockInterface_GetTransaction_Call) Run(run func(username string)) *MockInterface_GetTransaction_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_GetTransaction_Call) Return(_a0 []models.SentTransaction, _a1 []models.ReceivedTransaction, _a2 error) *MockInterface_GetTransaction_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1, _a2)
        return _c
}</span>

func (_c *MockInterface_GetTransaction_Call) RunAndReturn(run func(string) ([]models.SentTransaction, []models.ReceivedTransaction, error)) *MockInterface_GetTransaction_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Login provides a mock function with given fields: employee
func (_m *MockInterface) Login(employee *models.Employee) (models.Employee, error) <span class="cov8" title="1">{
        ret := _m.Called(employee)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Login")</span>
        }

        <span class="cov8" title="1">var r0 models.Employee
        var r1 error
        if rf, ok := ret.Get(0).(func(*models.Employee) (models.Employee, error)); ok </span><span class="cov0" title="0">{
                return rf(employee)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(*models.Employee) models.Employee); ok </span><span class="cov0" title="0">{
                r0 = rf(employee)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(models.Employee)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(*models.Employee) error); ok </span><span class="cov0" title="0">{
                r1 = rf(employee)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// MockInterface_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type MockInterface_Login_Call struct {
        *mock.Call
}

// Login is a helper method to define mock.On call
//   - employee *models.Employee
func (_e *MockInterface_Expecter) Login(employee interface{}) *MockInterface_Login_Call <span class="cov8" title="1">{
        return &amp;MockInterface_Login_Call{Call: _e.mock.On("Login", employee)}
}</span>

func (_c *MockInterface_Login_Call) Run(run func(employee *models.Employee)) *MockInterface_Login_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Employee))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_Login_Call) Return(_a0 models.Employee, _a1 error) *MockInterface_Login_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockInterface_Login_Call) RunAndReturn(run func(*models.Employee) (models.Employee, error)) *MockInterface_Login_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// Register provides a mock function with given fields: employee
func (_m *MockInterface) Register(employee *models.Employee) error <span class="cov8" title="1">{
        ret := _m.Called(employee)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for Register")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(*models.Employee) error); ok </span><span class="cov0" title="0">{
                r0 = rf(employee)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockInterface_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type MockInterface_Register_Call struct {
        *mock.Call
}

// Register is a helper method to define mock.On call
//   - employee *models.Employee
func (_e *MockInterface_Expecter) Register(employee interface{}) *MockInterface_Register_Call <span class="cov8" title="1">{
        return &amp;MockInterface_Register_Call{Call: _e.mock.On("Register", employee)}
}</span>

func (_c *MockInterface_Register_Call) Run(run func(employee *models.Employee)) *MockInterface_Register_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.Employee))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_Register_Call) Return(_a0 error) *MockInterface_Register_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockInterface_Register_Call) RunAndReturn(run func(*models.Employee) error) *MockInterface_Register_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// SendCoin provides a mock function with given fields: send
func (_m *MockInterface) SendCoin(send *models.SendCoin) error <span class="cov8" title="1">{
        ret := _m.Called(send)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SendCoin")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(*models.SendCoin) error); ok </span><span class="cov0" title="0">{
                r0 = rf(send)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockInterface_SendCoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendCoin'
type MockInterface_SendCoin_Call struct {
        *mock.Call
}

// SendCoin is a helper method to define mock.On call
//   - send *models.SendCoin
func (_e *MockInterface_Expecter) SendCoin(send interface{}) *MockInterface_SendCoin_Call <span class="cov8" title="1">{
        return &amp;MockInterface_SendCoin_Call{Call: _e.mock.On("SendCoin", send)}
}</span>

func (_c *MockInterface_SendCoin_Call) Run(run func(send *models.SendCoin)) *MockInterface_SendCoin_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(*models.SendCoin))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_SendCoin_Call) Return(_a0 error) *MockInterface_SendCoin_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockInterface_SendCoin_Call) RunAndReturn(run func(*models.SendCoin) error) *MockInterface_SendCoin_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// UpdateToken provides a mock function with given fields: id, token
func (_m *MockInterface) UpdateToken(id int, token string) error <span class="cov8" title="1">{
        ret := _m.Called(id, token)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateToken")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(int, string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(id, token)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// MockInterface_UpdateToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateToken'
type MockInterface_UpdateToken_Call struct {
        *mock.Call
}

// UpdateToken is a helper method to define mock.On call
//   - id int
//   - token string
func (_e *MockInterface_Expecter) UpdateToken(id interface{}, token interface{}) *MockInterface_UpdateToken_Call <span class="cov8" title="1">{
        return &amp;MockInterface_UpdateToken_Call{Call: _e.mock.On("UpdateToken", id, token)}
}</span>

func (_c *MockInterface_UpdateToken_Call) Run(run func(id int, token string)) *MockInterface_UpdateToken_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run(args[0].(int), args[1].(string))
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockInterface_UpdateToken_Call) Return(_a0 error) *MockInterface_UpdateToken_Call <span class="cov8" title="1">{
        _c.Call.Return(_a0)
        return _c
}</span>

func (_c *MockInterface_UpdateToken_Call) RunAndReturn(run func(int, string) error) *MockInterface_UpdateToken_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockInterface creates a new instance of MockInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInterface(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockInterface <span class="cov8" title="1">{
        mock := &amp;MockInterface{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>

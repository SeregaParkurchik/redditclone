// Code generated by mockery v2.52.2. DO NOT EDIT.

package storage

import (
	models "avito_shop/internal/models"

	mock "github.com/stretchr/testify/mock"
)

// MockInterface is an autogenerated mock type for the Interface type
type MockInterface struct {
	mock.Mock
}

type MockInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInterface) EXPECT() *MockInterface_Expecter {
	return &MockInterface_Expecter{mock: &_m.Mock}
}

// BuyItem provides a mock function with given fields: item, username
func (_m *MockInterface) BuyItem(item string, username string) error {
	ret := _m.Called(item, username)

	if len(ret) == 0 {
		panic("no return value specified for BuyItem")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(item, username)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_BuyItem_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BuyItem'
type MockInterface_BuyItem_Call struct {
	*mock.Call
}

// BuyItem is a helper method to define mock.On call
//   - item string
//   - username string
func (_e *MockInterface_Expecter) BuyItem(item interface{}, username interface{}) *MockInterface_BuyItem_Call {
	return &MockInterface_BuyItem_Call{Call: _e.mock.On("BuyItem", item, username)}
}

func (_c *MockInterface_BuyItem_Call) Run(run func(item string, username string)) *MockInterface_BuyItem_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(string))
	})
	return _c
}

func (_c *MockInterface_BuyItem_Call) Return(_a0 error) *MockInterface_BuyItem_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_BuyItem_Call) RunAndReturn(run func(string, string) error) *MockInterface_BuyItem_Call {
	_c.Call.Return(run)
	return _c
}

// CheckEmployee provides a mock function with given fields: username
func (_m *MockInterface) CheckEmployee(username string) (bool, error) {
	ret := _m.Called(username)

	if len(ret) == 0 {
		panic("no return value specified for CheckEmployee")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(username)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(username)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_CheckEmployee_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckEmployee'
type MockInterface_CheckEmployee_Call struct {
	*mock.Call
}

// CheckEmployee is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) CheckEmployee(username interface{}) *MockInterface_CheckEmployee_Call {
	return &MockInterface_CheckEmployee_Call{Call: _e.mock.On("CheckEmployee", username)}
}

func (_c *MockInterface_CheckEmployee_Call) Run(run func(username string)) *MockInterface_CheckEmployee_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockInterface_CheckEmployee_Call) Return(_a0 bool, _a1 error) *MockInterface_CheckEmployee_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_CheckEmployee_Call) RunAndReturn(run func(string) (bool, error)) *MockInterface_CheckEmployee_Call {
	_c.Call.Return(run)
	return _c
}

// GetCoins provides a mock function with given fields: username
func (_m *MockInterface) GetCoins(username string) (int, error) {
	ret := _m.Called(username)

	if len(ret) == 0 {
		panic("no return value specified for GetCoins")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (int, error)); ok {
		return rf(username)
	}
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(username)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetCoins_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCoins'
type MockInterface_GetCoins_Call struct {
	*mock.Call
}

// GetCoins is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) GetCoins(username interface{}) *MockInterface_GetCoins_Call {
	return &MockInterface_GetCoins_Call{Call: _e.mock.On("GetCoins", username)}
}

func (_c *MockInterface_GetCoins_Call) Run(run func(username string)) *MockInterface_GetCoins_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockInterface_GetCoins_Call) Return(_a0 int, _a1 error) *MockInterface_GetCoins_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetCoins_Call) RunAndReturn(run func(string) (int, error)) *MockInterface_GetCoins_Call {
	_c.Call.Return(run)
	return _c
}

// GetInventory provides a mock function with given fields: username
func (_m *MockInterface) GetInventory(username string) ([]models.Item, error) {
	ret := _m.Called(username)

	if len(ret) == 0 {
		panic("no return value specified for GetInventory")
	}

	var r0 []models.Item
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]models.Item, error)); ok {
		return rf(username)
	}
	if rf, ok := ret.Get(0).(func(string) []models.Item); ok {
		r0 = rf(username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Item)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_GetInventory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInventory'
type MockInterface_GetInventory_Call struct {
	*mock.Call
}

// GetInventory is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) GetInventory(username interface{}) *MockInterface_GetInventory_Call {
	return &MockInterface_GetInventory_Call{Call: _e.mock.On("GetInventory", username)}
}

func (_c *MockInterface_GetInventory_Call) Run(run func(username string)) *MockInterface_GetInventory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockInterface_GetInventory_Call) Return(_a0 []models.Item, _a1 error) *MockInterface_GetInventory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_GetInventory_Call) RunAndReturn(run func(string) ([]models.Item, error)) *MockInterface_GetInventory_Call {
	_c.Call.Return(run)
	return _c
}

// GetTransaction provides a mock function with given fields: username
func (_m *MockInterface) GetTransaction(username string) ([]models.SentTransaction, []models.ReceivedTransaction, error) {
	ret := _m.Called(username)

	if len(ret) == 0 {
		panic("no return value specified for GetTransaction")
	}

	var r0 []models.SentTransaction
	var r1 []models.ReceivedTransaction
	var r2 error
	if rf, ok := ret.Get(0).(func(string) ([]models.SentTransaction, []models.ReceivedTransaction, error)); ok {
		return rf(username)
	}
	if rf, ok := ret.Get(0).(func(string) []models.SentTransaction); ok {
		r0 = rf(username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.SentTransaction)
		}
	}

	if rf, ok := ret.Get(1).(func(string) []models.ReceivedTransaction); ok {
		r1 = rf(username)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]models.ReceivedTransaction)
		}
	}

	if rf, ok := ret.Get(2).(func(string) error); ok {
		r2 = rf(username)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockInterface_GetTransaction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTransaction'
type MockInterface_GetTransaction_Call struct {
	*mock.Call
}

// GetTransaction is a helper method to define mock.On call
//   - username string
func (_e *MockInterface_Expecter) GetTransaction(username interface{}) *MockInterface_GetTransaction_Call {
	return &MockInterface_GetTransaction_Call{Call: _e.mock.On("GetTransaction", username)}
}

func (_c *MockInterface_GetTransaction_Call) Run(run func(username string)) *MockInterface_GetTransaction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockInterface_GetTransaction_Call) Return(_a0 []models.SentTransaction, _a1 []models.ReceivedTransaction, _a2 error) *MockInterface_GetTransaction_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockInterface_GetTransaction_Call) RunAndReturn(run func(string) ([]models.SentTransaction, []models.ReceivedTransaction, error)) *MockInterface_GetTransaction_Call {
	_c.Call.Return(run)
	return _c
}

// Login provides a mock function with given fields: employee
func (_m *MockInterface) Login(employee *models.Employee) (models.Employee, error) {
	ret := _m.Called(employee)

	if len(ret) == 0 {
		panic("no return value specified for Login")
	}

	var r0 models.Employee
	var r1 error
	if rf, ok := ret.Get(0).(func(*models.Employee) (models.Employee, error)); ok {
		return rf(employee)
	}
	if rf, ok := ret.Get(0).(func(*models.Employee) models.Employee); ok {
		r0 = rf(employee)
	} else {
		r0 = ret.Get(0).(models.Employee)
	}

	if rf, ok := ret.Get(1).(func(*models.Employee) error); ok {
		r1 = rf(employee)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockInterface_Login_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Login'
type MockInterface_Login_Call struct {
	*mock.Call
}

// Login is a helper method to define mock.On call
//   - employee *models.Employee
func (_e *MockInterface_Expecter) Login(employee interface{}) *MockInterface_Login_Call {
	return &MockInterface_Login_Call{Call: _e.mock.On("Login", employee)}
}

func (_c *MockInterface_Login_Call) Run(run func(employee *models.Employee)) *MockInterface_Login_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Employee))
	})
	return _c
}

func (_c *MockInterface_Login_Call) Return(_a0 models.Employee, _a1 error) *MockInterface_Login_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockInterface_Login_Call) RunAndReturn(run func(*models.Employee) (models.Employee, error)) *MockInterface_Login_Call {
	_c.Call.Return(run)
	return _c
}

// Register provides a mock function with given fields: employee
func (_m *MockInterface) Register(employee *models.Employee) error {
	ret := _m.Called(employee)

	if len(ret) == 0 {
		panic("no return value specified for Register")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.Employee) error); ok {
		r0 = rf(employee)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_Register_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Register'
type MockInterface_Register_Call struct {
	*mock.Call
}

// Register is a helper method to define mock.On call
//   - employee *models.Employee
func (_e *MockInterface_Expecter) Register(employee interface{}) *MockInterface_Register_Call {
	return &MockInterface_Register_Call{Call: _e.mock.On("Register", employee)}
}

func (_c *MockInterface_Register_Call) Run(run func(employee *models.Employee)) *MockInterface_Register_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.Employee))
	})
	return _c
}

func (_c *MockInterface_Register_Call) Return(_a0 error) *MockInterface_Register_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_Register_Call) RunAndReturn(run func(*models.Employee) error) *MockInterface_Register_Call {
	_c.Call.Return(run)
	return _c
}

// SendCoin provides a mock function with given fields: send
func (_m *MockInterface) SendCoin(send *models.SendCoin) error {
	ret := _m.Called(send)

	if len(ret) == 0 {
		panic("no return value specified for SendCoin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(*models.SendCoin) error); ok {
		r0 = rf(send)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_SendCoin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendCoin'
type MockInterface_SendCoin_Call struct {
	*mock.Call
}

// SendCoin is a helper method to define mock.On call
//   - send *models.SendCoin
func (_e *MockInterface_Expecter) SendCoin(send interface{}) *MockInterface_SendCoin_Call {
	return &MockInterface_SendCoin_Call{Call: _e.mock.On("SendCoin", send)}
}

func (_c *MockInterface_SendCoin_Call) Run(run func(send *models.SendCoin)) *MockInterface_SendCoin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*models.SendCoin))
	})
	return _c
}

func (_c *MockInterface_SendCoin_Call) Return(_a0 error) *MockInterface_SendCoin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_SendCoin_Call) RunAndReturn(run func(*models.SendCoin) error) *MockInterface_SendCoin_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateToken provides a mock function with given fields: id, token
func (_m *MockInterface) UpdateToken(id int, token string) error {
	ret := _m.Called(id, token)

	if len(ret) == 0 {
		panic("no return value specified for UpdateToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string) error); ok {
		r0 = rf(id, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockInterface_UpdateToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateToken'
type MockInterface_UpdateToken_Call struct {
	*mock.Call
}

// UpdateToken is a helper method to define mock.On call
//   - id int
//   - token string
func (_e *MockInterface_Expecter) UpdateToken(id interface{}, token interface{}) *MockInterface_UpdateToken_Call {
	return &MockInterface_UpdateToken_Call{Call: _e.mock.On("UpdateToken", id, token)}
}

func (_c *MockInterface_UpdateToken_Call) Run(run func(id int, token string)) *MockInterface_UpdateToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int), args[1].(string))
	})
	return _c
}

func (_c *MockInterface_UpdateToken_Call) Return(_a0 error) *MockInterface_UpdateToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockInterface_UpdateToken_Call) RunAndReturn(run func(int, string) error) *MockInterface_UpdateToken_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockInterface creates a new instance of MockInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInterface {
	mock := &MockInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
